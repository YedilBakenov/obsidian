
1. фигма - https://www.figma.com/board/NThnrinP3Wb3ljzlTMYVsR/Трек-водителя?node-id=0-1&p=f&t=sP5vrH7O09Vx4SvP-0
2. календарь - https://calendar.google.com/calendar/u/0/r?msg=Не+удалось+найти+указанное+мероприятие.&msgtok=de5155cf23f37793c6a1dafd384e4089a6e51574
3. https://youtu.be/DSjNQ1nn7WM - запись видео по трекам
4. Нурлан - Но в целом нужны будут либы для кассандры, кафки, http запросов (клиент/сервер), и дальше по необходимости. Могут понадобиться либы для redis, elastic, clickhouse. Точно будут нужны:  `cats` , `cats-effect` , `http4s` , `fs2` , `circe` , `fs2-kafka` , `cassandra4io`
    по ситуации:  `rediculous` , `elastic4s`
5. Смотреть Нурлана микросервисы - такие как рита, по уведомлениям на почту
6. Похоже уже реализован микросервис, который смотрит по трекам, только клиентским на менеджменте - уточнить и самому посмотреть точно - Дима сказал такого нет, нужно уточнить # Activity # gdeYa # rita # tailwhip # intercity #  keiji 

Нужна интернал спецификация для интеграции с менеджментом для получения трека   

Водительская спецификация - нужна только дырка куда будет водительская слать координаты. В водительском никаких кнопок не будет. В водительском будут только http запросы куда будут слаться координаты, скорость и так далее. Данные берутся из спеки, которую написал Дима для треков:
https://gitlab.com/hivetaxi/specs/http-specs-gw-driver/-/commit/0532395af503b05c34bba94a0518dc3862bc64b5

Общий эпик и с протоспеками:
https://hivetaxi.atlassian.net/browse/HD-8340

Протоспецификации для работы с кафкой. Дима подготовил для сервиса:
https://gitlab.com/hivetaxi/specs/proto-specs-services/-/commit/cdd193068542d9d0a86c10841d8d8b001476fa1d

grpc не будет

Нужно сделать интеграцию с другими сервисами:
Core, kar-karta,  Driver Service

GeoIndex

папка geoindex - SessionLcationActor

Таблицы:
1. С координатами (lat, lon), мета(скорость, и остальная хрень) - можно сделать разные колонки, можно сделать одну большую колонку,  координаты надо класть по дням, группировать по дням, патришен кей будет драйвер uuid и день, кластеринг ключ будет дата
2. статусы - праймари кей тот же самый - водитель, день и потом все изменения складываются по датам и действия - какие события были совершены водителем 
	за день. Перемещения между статусами - это одно из действий. source - это откуда - кора, хэгл или еще откуда, опциональный orderId - потому что некотые события не привязаны к заказу, а некоторые привязаны

3. Таблица в которой хранятся все статусы по заказу. Получить все события по заказу. 

Нужно понять в какую таблицу складывать начало конец заказа, события - заказ принят, водитель назначен, водитель снят, заказ завершен, чтобы было понятно где начало и где конец заказа - только для этого используется таблица. Все остальные данные все равно будут браться из другой таблицы. 


	Данные по заказу - из коры события кидабтся(driverStatusUpdated, driverStatusEvents) они пробрасываются по акке - нужно написать актор продюсер, который будет слушать вот эти 3 события и будет их продюсить запихивать в топик в который складываются статусы и есть еще complitedOrderEvents стрим акковский - все завершенные заказы. Когда заказа завершен - можно взять все дейсвтия по заказу и закинуть можно их в топик.

МОжет быть такое что два водителя выполнили один заказ - нужно будет для каждого послать событие, достаем водителей по driverId

TaximeterData  - там будет написано - пауза, поехали, например если клиент попросил остановиться, водитель нажал паузу, чтобы было видно чтобы в этот момент таксометр не считал. Когда водитель стоит и прсото ждет - это по другому тарифицируется - важно видеть на карте, когда водитель нажал на паузу и когда поехал. Данная информация есть только в данных таксометра - жто оттуда надо брать - детально Дима позже подскажет

Можно сделать две отдельные колонки с lat lon, а не terki.position_udt.

terki.track_event_udt - Диме не нравится, потому что если мы захотим сюда что-нибудб добавить или удалить - мы не сможем это сделать, лучше сделать это табдицей

Важно, чтобы партиция была driverId и дата. meta - грубо говоря что данные в одну строку хранятся, пишется все в одну партицию - а это плохо. Потому что все данные записываются в одно место. Нам нужно получать данные ровно по одному водителю. а когда мета в партиции - мы получаем все данные по всем водителям. 

Primary key должен быть id заказа

у нас треки пишутся беспрерывно
Нужно просто таблица в которой лежат координаты, каждая строчка - это точка. Т.е. как водитель открыд приложение - так и начинается писаться в базу как он ездит. Хочешь по дате посмотреть как он ездил, хочешь по подителю, хочешь по id заказа

Уже у нас есть уже данная логика на коре и сейчас водительская всешда записывает данные, когда приложение активно у водителя. каждые три секунды шлет данные. location.update - запрос. - кладет в geoIndex SessionLocator скидывает координаты. 
Актор получает geoIndexSentry и обновляет позицию водителя в кэше

ОТзывы не нужны на сервсие и соответсвенно таблица такая не нужна

Нужно информацию о координатах не только в базу писать, но и опевещать кору и каркарту, которые работают с координатами. То что прислала водительская нужно дублировать еще в топик (lat, lon, driverId)

Топик со статусами, действиями - (действия по заказу, действия не по заказу)

ПО заказу - заказ предложен водителю
Водитель предложен клиенту - это в договорных(assigned, arrived, executing)
`Idle`- когда включаем платный простой
`Discharging` - освобождаюсь
Данные все из прото-спеки

Connected = 0;
Disconnected = 1;
ShiftStarted = 2;
ShiftEnded = 3; данные все события надо хранить

события делятся на два типа - одни по заказу, другие не по заказу, у одних есть orderId, у других нет - вот и вся разница между ними.

Есть один запрос с водительского http - заполняется табличка с координатами. А статусы буду по кафке заполнять. 


Дима сделал топик по всем событиям - уточнить про жто же речь - https://gitlab.com/hivetaxi/specs/proto-specs-services/-/commit/cdd193068542d9d0a86c10841d8d8b001476fa1d ?

Ендпоинт сделать на коре один в один как и других сервисов, например intercity  

все данные о водители берем из коры

по example mapping:
1. Фиолетовое - новое, нужно делать
2. Желтое - актуальное. нужно сохранить
3. Красное - старое, нужно не использовать

terki.driver_daily_summary - это прикольная идея, но у нас такого нет в идеях пока - можно предложить
terki.driver_route_stats - можно все добавить в одну таблицу  terki.driver_daily_summary, но пока нет такой задачи

события по заказу и не по заказу в одной таблице

Событий RESTART, CRASH - таких нет, (LOGIN, LOGOUT) - это онлайн и не онлайн

Consumer в CarCArta, Core - запись в geoIndex

Часть со статусами - она еще сыра в коре, надо думать

Core сейчас берет driverId из авторизации напрямую, надо будет брать  driverId и преобразовывать его в uuid на коре - geoIndexEntry - нужно чтобы консюмер в коре делал ровно тоже. Uuid поменять на старый driverId и отправить точно такое же сообщение тому же актору и все остальное само заработает. Просто широту долготу отправить и все.

Нам в carCarta нужен угол, а в коре нужен только lat lon - больше ничего не нужно

WorkerId - это старый driverId числовой - берется из сессии.

В топик пишем все что есть driverUuid из заголовка, остальное из тела запроса(lat, lon, bearing, speed , source, data - сейчас) - продюсим консюмим и кладем в базу

Дима писал meta - потому что ему было лень писать 3 слова(bearing, speed , source) в фигме.

В коре надо толтко lat lon
В carCarta - нужно lat lon bearing(угол)  dt(дата)

bearing(угол) - 360 градусов, как машинка едет на карте, как отражается на карте

водительская уже умеет

carCArta - это сервис, который показывает машинки на карте, 

Как сейчас работает- по вебсокету запрос Location.update (lat, lon) по которому отправляется широта долгота в кору, кора кладет в GeoIndex(SessionLocationActor). GeoIndex продюсит эти координаты в топик, driverId - превращает в документ и шлет в топик, а этот топик учитывает CarCarta и кладет в cash. 

Как надо - чтобы у водительского появился новый запрос. Этот запрос шлет координаты. Видимо тот запрос, который написал Дима в новой спеки open api.
Он продюсит и сервис сам себя слушает. и записывает в базу. Сначала сохранил в кафку, а из кафки сохранил в базу. Из этого сервиса читает не только terki, а еще carcarta. Сейчас она консюмит из топика который в коре, а будет читать из другого топика. Надо будет в carcarta поменять топик из которого будет идти чтение. Легко будет поменять. И из этого топика из которого будет читать и терки и каркарта и из него будет читать кора. 


private def compat(driverUuid: DriverUuid): Future[DriverId] =  
  DriverDocumentsService  
    .getDriverDocument(driverUuid)  
    .flatMap(_.traverse(findByDocument))  
    .map(_.map(_.toString))  
    .flatMap(_.fold(Future.failed[String] {  
      log.error("DriverUuid: {} is incompatible candidate to occupied|freed", driverUuid)  
      CompatException(driverUuid)  
    })(id => Future.successful(id)))  
  
private def findByDocument(document: String): Future[Long] =  
  DriverContext  
    .getDriverByDocument(document)  
    .ask  
    .map(_.driverId)
def getDriverByDocument(document: String): ActorCommand[DriverInfo] =  
  ActorCommand(actor, GetDriverInfoByDocument(document))


по топику будет приходить driverUuid и я смогу его превращать в driverId. Это уже есть в коре.  

В кору когда идет driverUuid то проходит через SessionLocationActor дальше все также. Когда кора хочет получить координаты водителя - она все идет в геоиндекс. Сама все заработает. 
 
задача - заменить данную цепочку на новую. Запрос также будет идти через GeoIndex, но еще и через новый способ. Не должна ломаться совместимость

Будет топик отдельный для договорных заказов, который будет сдать все действия по orderId driverId ??

Два типа - действия по заказу и действия не по заказу - два енума
перекладываются в данный топик и он складывается в базу как есть . События кладутся в базу по таким ключам, чтобы потом можно было их доставать

На вход будет приходить либо orderId либо driverId, скорее всего driverId

Нужно будет вернуть с таблицы и события и с таблицы шде маршрут нарисован - нужно будет их объеденить в одну штуку и вернуть - массив, лат лон мета dt type source orderid

Клиентских маршрутов не будет, будут только как точки клиентов, где они находятся, по которым будет ориентироваться водитель


Первую инициализаю сделать по точкам lat lon - все остальное по событиям оставить на потом