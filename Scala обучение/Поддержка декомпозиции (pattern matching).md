
#Scala 

Поддержка декомпозиции (pattern matching) в Scala - это мощная и гибкая концепция, позволяющая сопоставлять структуры данных и выражения с шаблонами и выполнять различные действия в зависимости от соответствия этих шаблонов. Это позволяет более компактно и выразительно описывать разветвленные логические пути и операции над данными.

Рассмотрим примеры поддержки декомпозиции в Scala:

### Пример 1: Декомпозиция кортежей

val tuple = (1, "hello", 3.14)

tuple match {
  case (1, str, _) => println(s"First element is 1, second element is $str")
  case (_, _, pi) => println(s"Pi value is $pi")
  case _ => println("No match")
}

### Пример 2: Декомпозиция списка

val list = List(1, 2, 3)

list match {
  case Nil => println("Empty list")
  case head :: tail => println(s"Head: $head, Tail: $tail")
  case _ => println("No match")
}

В этом примере мы сопоставляем список с шаблонами. Если список пустой (`Nil`), то выполняется соответствующий блок. Если список не пустой, то мы извлекаем голову списка как `head`, а хвост как `tail`.

Декомпозиция в Scala позволяет использовать более сложные шаблоны и даже рекурсивные структуры данных для сопоставления. Это делает код более читаемым, выразительным и легко поддерживаемым.