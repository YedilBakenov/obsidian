#Scala 

Функции высшего порядка в Scala - это функции, которые могут принимать другие функции в качестве аргументов или возвращать функции как результат своей работы. Такой подход позволяет нам работать с функциями как с данными, передавать их в качестве параметров, возвращать из других функций, сохранять в переменных и т.д. Это делает код более гибким, позволяет создавать абстракции и улучшает читаемость кода.

Примеры функций высшего порядка:

1. Передача функции в качестве параметра:

scalaCopy code

`def doOperation(x: Int, y: Int, operation: (Int, Int) => Int): Int = {   operation(x, y) }  // Определяем функцию для сложения двух чисел val add = (a: Int, b: Int) => a + b  // Определяем функцию для умножения двух чисел val multiply = (a: Int, b: Int) => a * b  // Вызываем функцию doOperation, передавая функцию add в качестве параметра val result1 = doOperation(5, 3, add) // Результат: 8  // Вызываем функцию doOperation, передавая функцию multiply в качестве параметра val result2 = doOperation(5, 3, multiply) // Результат: 15`

2. Возвращение функции:

scalaCopy code

`def operationFactory(operator: String): (Int, Int) => Int = {   if (operator == "+") {     (a: Int, b: Int) => a + b   } else if (operator == "-") {     (a: Int, b: Int) => a - b   } else {     (a: Int, b: Int) => a * b   } }  val addFunction = operationFactory("+") val subtractFunction = operationFactory("-") val multiplyFunction = operationFactory("*")  val result1 = addFunction(5, 3) // Результат: 8 val result2 = subtractFunction(5, 3) // Результат: 2 val result3 = multiplyFunction(5, 3) // Результат: 15`

В приведенных примерах функции `add` и `multiply` - это лямбда-функции, определенные с помощью синтаксиса `(параметры) => выражение`. Функции `doOperation` и `operationFactory` являются функциями высшего порядка, потому что они принимают или возвращают другие функции.

Функции высшего порядка играют важную роль в функциональном программировании и часто используются в Scala для создания более абстрактного, гибкого и элегантного кода.

val salaries = Seq(20_000, 70_000, 40_000) val newSalaries = salaries.map(x => x * 2)

`doubleSalary` - это функция, которая принимает один Int `x` и возвращает `x * 2`. В общем случае, кортеж (список имен в скобках) слева от стрелки `=>` - это список параметров, а значение выражения следует справа. Это же значение возвращается в качестве результата. В строке 3 к каждому элементу списка зарплат (salaries) применяется функция `doubleSalary`.

Чтобы сократить код, мы можем сделать функцию анонимной и передать ее напрямую в качестве аргумента в map:

- Scala 2 и 3

```scala
val salaries = Seq(20_000, 70_000, 40_000)
val newSalaries = salaries.map(x => x * 2) // List(40000, 140000, 80000)
```

Обратите внимание, что в приведенном выше примере `x`не объявлен как `Int`. Это потому, что компилятор может вывести тип, основываясь на типе который ожидает функция map. Еще более элегантным способом написания этого же кода было бы таким:

- Scala 2 и 3

```scala
val salaries = Seq(20_000, 70_000, 40_000)
val newSalaries = salaries.map(_ * 2)
```

Поскольку компилятор Scala уже знает тип параметров (Int), вам нужно только указать правую часть функции. Единственное условие заключается в том, что вместо имени параметра необходимо использовать `_` (в предыдущем примере это было `x`).

## Преобразование методов в функции[](https://docs.scala-lang.org/ru/tour/higher-order-functions.html#%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%BE%D0%B2-%D0%B2-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8)

Также возможно передавать методы в качестве аргументов функциям более высокого порядка, поскольку компилятор Scala может преобразовать метод в функцию.

- Scala 2
- Scala 3

```scala
case class WeeklyWeatherForecast(temperatures: Seq[Double]) {

  private def convertCtoF(temp: Double) = temp * 1.8 + 32

  def forecastInFahrenheit: Seq[Double] = temperatures.map(convertCtoF) // <-- передается метод convertCtoF
}
```

```scala
case class WeeklyWeatherForecast(temperatures: Seq[Double]):

  private def convertCtoF(temp: Double) = temp * 1.8 + 32

  def forecastInFahrenheit: Seq[Double] = temperatures.map(convertCtoF) // <-- передается метод convertCtoF
```

Здесь метод `convertCtoF` передается в `forecastInFahrenheit`. Это возможно, потому что компилятор преобразовывает `convertCtoF` в функцию `x => ConvertCtoF(x)` (примечание: `x` будет сгенерированным именем, которое гарантированно будет уникальным в рамках своей области видимости).

## Функции, которые принимают функции[](https://docs.scala-lang.org/ru/tour/higher-order-functions.html#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5-%D0%BF%D1%80%D0%B8%D0%BD%D0%B8%D0%BC%D0%B0%D1%8E%D1%82-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8)

Одной из причин использования функций высшего порядка является сокращение избыточного кода. Допустим, вам нужны какие-то методы, которые могли бы повышать чью-то зарплату по разным условиям. Без создания функции высшего порядка это могло бы выглядеть примерно так:

object SalaryRaiser {

  def smallPromotion(salaries: List[Double]): List[Double] =
    salaries.map(salary => salary * 1.1)

  def greatPromotion(salaries: List[Double]): List[Double] =
    salaries.map(salary => salary * math.log(salary))

  def hugePromotion(salaries: List[Double]): List[Double] =
    salaries.map(salary => salary * salary)
}
```

```scala
object SalaryRaiser:

  def smallPromotion(salaries: List[Double]): List[Double] =
    salaries.map(salary => salary * 1.1)

  def greatPromotion(salaries: List[Double]): List[Double] =
    salaries.map(salary => salary * math.log(salary))

  def hugePromotion(salaries: List[Double]): List[Double] =
    salaries.map(salary => salary * salary)
```

Обратите внимание, что каждый из этих трех методов отличается только коэффициентом умножения. Для упрощения можно перенести повторяющийся код в функцию высшего порядка:

- Scala 2
- Scala 3

```scala
object SalaryRaiser {

  private def promotion(salaries: List[Double], promotionFunction: Double => Double): List[Double] =
    salaries.map(promotionFunction)

  def smallPromotion(salaries: List[Double]): List[Double] =
    promotion(salaries, salary => salary * 1.1)

  def greatPromotion(salaries: List[Double]): List[Double] =
    promotion(salaries, salary => salary * math.log(salary))

  def hugePromotion(salaries: List[Double]): List[Double] =
    promotion(salaries, salary => salary * salary)
}
```

```scala
object SalaryRaiser:

  private def promotion(salaries: List[Double], promotionFunction: Double => Double): List[Double] =
    salaries.map(promotionFunction)

  def smallPromotion(salaries: List[Double]): List[Double] =
    promotion(salaries, salary => salary * 1.1)

  def greatPromotion(salaries: List[Double]): List[Double] =
    promotion(salaries, salary => salary * math.log(salary))

  def hugePromotion(salaries: List[Double]): List[Double] =
    promotion(salaries, salary => salary * salary)
```

Новый метод, `promotion`, берет зарплату и функцию типа `Double => Double` (т.е. функция, которая берет Double и возвращает Double) и возвращает их произведение.

Методы и функции обычно выражают поведение или преобразование данных, поэтому наличие функций, которые компонуются на основе других функций, может помочь в создании общих механизмов. Эти типовые функции откладывают блокировку всего поведения операции, предоставляя клиентам возможность контролировать или дополнительно настраивать части самой операции.

## Функции, возвращающие функции[](https://docs.scala-lang.org/ru/tour/higher-order-functions.html#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D1%8E%D1%89%D0%B8%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8)

Есть определенные случаи, когда вы хотите сгенерировать функцию. Вот пример метода, который возвращает функцию.

- Scala 2
- Scala 3

```scala
def urlBuilder(ssl: Boolean, domainName: String): (String, String) => String = {
  val schema = if (ssl) "https://" else "http://"
  (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
}

val domainName = "www.example.com"
def getURL = urlBuilder(ssl=true, domainName)
val endpoint = "users"
val query = "id=1"
val url = getURL(endpoint, query) // "https://www.example.com/users?id=1": String
```

```scala
def urlBuilder(ssl: Boolean, domainName: String): (String, String) => String =
  val schema = if ssl then "https://" else "http://"
  (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"

val domainName = "www.example.com"
def getURL = urlBuilder(ssl=true, domainName)
val endpoint = "users"
val query = "id=1"
val url = getURL(endpoint, query) // "https://www.example.com/users?id=1": String
```

Обратите внимание, что возвращаемый тип urlBuilder`(String, String) => String`. Это означает, что возвращаемая анонимная функция принимает две строки и возвращает строку. В нашем случае возвращаемая анонимная функция `(endpoint: String, query: String) => s"https://www.example.com/$endpoint?$query"`.