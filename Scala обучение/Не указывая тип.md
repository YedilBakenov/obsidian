
#Scala 

Компилятор Scala часто может вывести тип выражения, так что вам не нужно указывать его явным образом.

## Не указывая тип[](https://docs.scala-lang.org/ru/tour/type-inference.html#%D0%BD%D0%B5-%D1%83%D0%BA%D0%B0%D0%B7%D1%8B%D0%B2%D0%B0%D1%8F-%D1%82%D0%B8%D0%BF)

- Scala 2 и 3

```scala
val businessName = "Montreux Jazz Café"
```

Компилятор может определить, что тип константы `businessName` является `String`. Аналогичным образом это работает и для методов:

- Scala 2 и 3

```scala
def squareOf(x: Int) = x * x
```

Компилятор может определить, что возвращаемый тип является `Int`, поэтому явного указания типа не требуется.

Для рекурсивных методов компилятор не в состоянии вывести тип. Вот программа, которая не скомпилируется по этой причине:

- Scala 2
- Scala 3

```scala
def fac(n: Int) = if (n == 0) 1 else n * fac(n - 1)
```

```scala
def fac(n: Int) = if n == 0 then 1 else n * fac(n - 1)
```

Также необязательно указывать параметры типа при вызове [полиморфных методов](https://docs.scala-lang.org/ru/tour/polymorphic-methods.html) или [обобщенных классов](https://docs.scala-lang.org/ru/tour/generic-classes.html). Компилятор Scala определит тип параметра из контекста и из типов фактически передаваемых параметров метода/конструктора.

Вот два примера:

- Scala 2 и 3

```scala
case class MyPair[A, B](x: A, y: B)
val p = MyPair(1, "scala") // тип: MyPair[Int, String]

def id[T](x: T) = x
val q = id(1)              // тип: Int
```

Компилятор использует типы аргументов `MyPair` для определения типа `A` и `B`. Тоже самое для типа `x`.

## Параметры[](https://docs.scala-lang.org/ru/tour/type-inference.html#%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D1%8B)

Для параметров компилятор никогда не выводит тип. Однако, в некоторых случаях, он может вывести типы для параметров анонимной функции при передаче ее в качестве аргумента.

- Scala 2 и 3

```scala
Seq(1, 3, 4).map(x => x * 2)  // List(2, 6, 8)
```

Параметр у map - `f: A => B` (функциональный параметр переводящий тип из A в B). Поскольку мы разместили целые числа в нашей последовательности `Seq`, компилятор знает, что элемент `A` является `Int` (т.е. `x` является целым числом). Поэтому компилятор может определить из выражения `x * 2`, что результат (`B`) является типом `Int`.

## Когда _не следует_ полагаться на выведение типа[](https://docs.scala-lang.org/ru/tour/type-inference.html#%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0-%D0%BD%D0%B5-%D1%81%D0%BB%D0%B5%D0%B4%D1%83%D0%B5%D1%82-%D0%BF%D0%BE%D0%BB%D0%B0%D0%B3%D0%B0%D1%82%D1%8C%D1%81%D1%8F-%D0%BD%D0%B0-%D0%B2%D1%8B%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0)

Обычно считается, наиболее удобочитаемым объявить тип членов, которые открыты для публичного использования через API. Поэтому мы рекомендуем вам явно указывать тип для любых API, которые будут доступны пользователям вашего кода.

Кроме того, выведение может иногда приводить к слишком специфичному типу. Предположим, мы напишем:

- Scala 2 и 3

```scala
var obj = null
```

Тогда мы не сможем далее сделать это переназначение:

- Scala 2 и 3

```scala
obj = new AnyRef
```

Такое не будет компилироваться, потому что для `obj` предполагался тип `Null`. Поскольку единственным значением этого типа является `null`, то невозможно присвоить другое значение.