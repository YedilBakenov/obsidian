
#Scala 
#Ответы 

1. В Scala 3 концепция "extension methods" была введена для более гибкой и понятной реализации подобной функциональности. Теперь вместо "implicit classes" вы можете использовать "extension methods", которые являются более декларативными и предсказуемыми.
    
    Пример с использованием "extension methods":
    
implicit class RichInt(value: Int) { def squared: Int = value * value }
    
extension (value: Int) 
def squared: Int = value * value`
    
    Здесь `(value: Int)` означает, что мы добавляем метод `squared` к типу `Int`.
    
    Как видите, синтаксис более лаконичный и понятный. Кроме того, "extension methods" также могут быть определены в разных местах, что делает код более организованным.
    

Таким образом, "extension methods" в Scala 3 предоставляют более удобный и ясный способ добавления новых методов к существующим типам без использования "implicit classes".


1. **Упрощение синтаксиса**: В Scala 3 был упрощен синтаксис для объявления и использования имплицитных значений. Ключевое слово `implicit` больше не используется, и вместо этого используется ключевое слово `given` для объявления и `using` для использования.
    
2. **`given` и `using`**: Вместо `implicit val` или `implicit def`, теперь в Scala 3 вы объявляете имплицитные значения с помощью ключевого слова `given`. Кроме того, для использования имплицитных значений вы используете ключевое слово `using`.
    
    Пример объявления и использования имплицитного значения:
    
    scalaCopy code
    
    given defaultName: String = "Гость" 
     def greet(name: String)(using default: String): String =  
      s"Привет, $name! Добро пожаловать к нам!" 
      
	val message = greet("Иван")
	println(message) // Вывод: Привет, Иван! Добро пожаловать к нам!`
    
3. **Типовые классы для имплицитов**: В Scala 3 можно определять так называемые "типовые классы" (type classes) с помощью `given`. Типовые классы позволяют определять интерфейсы, которые позволяют создавать имплементации для различных типов данных.
    
    Пример типового класса с использованием `given`:
    
    scalaCopy code
    
    trait Show[A] {  
    def show(a: A): String
     }  
     
     given Show[Int] with 
       def show(a: Int): String = a.toString  
       
    given Show[String] with  
     def show(a: String): String = a 
    def printShow[A](a: A)(using showInstance: Show[A]): Unit =   println(showInstance.show(a)) 
     printShow(42)      // Вывод: 42 printShow("Hello") // Вывод: Hello`
    
4. **Контекстные абстракции**: Scala 3 представляет новую концепцию "контекстных абстракций", которые позволяют более явно указывать требуемые контекстные зависимости для функций и методов.
    
    Пример использования контекстных абстракций:
    
    scalaCopy code
    
    `def greet(name: String)(using default: String): String =   s"Привет, $name! Добро пожаловать к нам!"  val message = greet("Иван")(using "Гость") println(message) // Вывод: Привет, Иван! Добро пожаловать к нам!`
    

Эти изменения делают использование имплицитов более явным, предсказуемым и удобным, что способствует более чистому и понятному коду.